Git은 내부적으로 크게 3가지 종류의 작업 영역을 두고 동작합니다.

각 작업 영역의 이름은

1)working directory
2)staging area
3)repository
입니다. 순서대로 하나씩 설명해드릴게요.

첫 번째 작업 영역인 working directory는 작업을 하는 프로젝트 디렉토리를 말합니다. 
그러니까 지금 상황에서는 MathTool 디렉토리가 working directory입니다.

두 번째 작업 영역인 staging area는 git add를 한 파일들이 존재하는 영역입니다. 
커밋을 하게되면 staging area에 있는 파일들만 커밋에 반영됩니다.

세 번째 작업 영역인 repository는 working directory의 변경 이력들이 저장되어 있는 영역입니다. 
그러니까 커밋들이 저장되는 영역이라는 뜻인데요. 조금 풀어서 설명해볼게요.

working directory에서 뭔가 작업을 하고,
작업한 파일들을 git add 해주고,
커밋을 하면 staging area에 있던 파일들의 모습이 마치 영화의 한 장면, 스냅샷(snapshot)처럼 이 repository에 저장되는 겁니다.




이전 노트에서 Git의 3가지 작업 영역을 배웠습니다. 

작업 영역과 관련해서 한 가지 더 알아두면 좋은 내용이 있는데요.

그건 바로 Git으로 관리되는 파일은 일종의 '상태(status)'라는 걸 가진다는 사실입니다. 
일단 Git에서 파일들은 크게 다음 2가지 상태를 가집니다.

Untracked 상태
Tracked 상태 
그리고 Tracked 상태는 다시 아래와 같은 3가지 상태로 나눌 수 있구요. 

Staged 상태
Unmodified 상태
Modified 상태
각 상태를 순서대로 설명해드릴게요.

1. Untracked 상태

Untracked는 '추적되지 않고 있는'이라는 뜻입니다. 
이 상태는 파일이 Git에 의해서 그 변동사항이 전혀 추적되고 있지 않는 상태를 뜻합니다. 
예를 들어, 파일을 새로 생성하고 그 파일을 한 번도 git add 해주지 않았다면 이 상태입니다.

2. Tracked 상태

파일이 Git에 의해 그 변동사항이 추적되고 있는 상태입니다. 
이 상태는 다시 그 특성에 따라 3가지 상태로 나뉩니다. 하나씩 설명할게요.

(1) Staged 상태

파일의 내용이 수정되고나서, staging area에 올라와있는 상태를 Staged(스테이징된, stage area에 올려진) 상태라고 합니다.
새로 생성한 파일에 내용을 쓰고 git add를 해주거나
한 번이라도 커밋에 포함됐었던 파일이라도 내용을 수정하고 git add를 해주면 이 상태입니다.

(2) Unmodified 상태
현재 파일의 내용이 최신 커밋의 모습과 비교했을 때 전혀 바뀐 게 없는 상태면 그 파일은 Unmodified(수정되지 않은, 변한 게 없는) 상태입니다. 
커밋을 하고 난 직후에는 working directory 안의 모든 파일들이 이 상태가 됩니다.

(3) Modified 상태
최신 커밋의 모습과 비교했을 때 조금이라도 바뀐 내용이 있는 상태면 그 파일은 Modified(수정된) 상태입니다.

이렇게 Git에서 파일은 매 순간 4가지 상태 중 하나의 상태에 있게 됩니다. 이 내용을 그림으로 정리하면 아래와 같습니다.

어떤 경우에, 어떻게 상태 전환이 발생하는지 주의깊게 살펴보세요. 각 경우를 설명하자면 아래 내용과 같습니다.

Add the file : Untracked 상태의 파일을 처음으로 git add 해주면 Staged 상태가 됩니다.
Edit the file : 최신 커밋과 비교했을 때 차이가 없는 Unmodified 상태의 파일의 내용을 수정하면 Modified 상태가 됩니다.
Stage the file : Modified 상태의 파일을 git add 해주면 Staged 상태가 됩니다. 
Remove the file : 파일을 삭제하면 당연히 Git에서 더이상 인식하지 않겠죠?
Commit : 커밋을 하면 staging area에 있던 파일들이 커밋에 반영되고, 이제 모든 파일들은 최신 커밋과 차이가 없게 되니까 Unmodified 상태가 됩니다. 


git init : 현재 디렉토리를 Git이 관리하는 프로젝트 디렉토리(=working directory)로 설정하고 그 안에 레포지토리(.git 디렉토리) 생성
git config user.name 'codeit' : 현재 사용자의 아이디를 'codeit'으로 설정(커밋할 때 필요한 정보)
git config user.email 'teacher@codeit.kr' : 현재 사용자의 이메일 주소를 'teacher@codeit.kr'로 설정(커밋할 때 필요한 정보)
git add [파일 이름] : 수정사항이 있는 특정 파일을 staging area에 올리기
git add [디렉토리명] : 해당 디렉토리 내에서 수정사항이 있는 모든 파일들을 staging area에 올리기 
git add . : working directory 내의 수정사항이 있는 모든 파일들을 staging area에 올리기
git reset [파일 이름] : staging area에 올렸던 파일 다시 내리기
git status : Git이 현재 인식하고 있는 프로젝트 관련 내용들 출력(문제 상황이 발생했을 때 현재 상태를 파악하기 위해 활용하면 좋음) 
git commit -m "커밋 메시지" : 현재 staging area에 있는 것들 커밋으로 남기기
git help [커맨드 이름] : 사용법이 궁금한 Git 커맨드의 공식 메뉴얼 내용 출력

이번 챕터에서 배운 커맨드들을 정리해볼게요.

git push -u origin master : 로컬 레포지토리의 내용을 처음으로 리모트 레포지토리에 올릴 때 사용합니다.(-u origin master가 무슨 뜻인지는 'Git에서 브랜치 사용하기' 챕터에서 배울 거니까 걱정마세요!)
git push : 로컬 레포지토리의 내용을 리모트 레포지토리에 보내기 
git pull : 리모트 레포지토리의 내용을 로컬 레포지토리로 가져오기
git clone [프로젝트의 GitHub 상 주소] : GitHub에 있는 프로젝트를 내 컴퓨터로 가져오기


이때까지 영상에서 계속 커밋 히스토리를 보기위해

> git log  
커맨드를 사용해왔습니다.

그리고 커밋 하나당 한 줄씩 보기 위해

--pretty=oneline
이라는 옵션을 붙여서 사용하고 있죠.

그런데 옵션이 좀 길죠? 이렇게 긴 옵션을 매번 붙여서 사용하는 건 좀 힘들 것 같은데요. 
Git에는 이렇게 길이가 긴 경우의 커맨드 전체에 별명을 붙여서 그 별명을 사용할 수 있도록 해주는 기능이 있습니다.
이 때 붙이는 별명을 alias라고 하고, 별명을 붙이는 행위를 aliasing이라고 합니다.

그럼 한번 aliasing을 해보겠습니다.

git log --pretty=oneline을
git history라는 별명으로
aliasing해보겠습니다. 어떻게 하면 될까요?

aliasing을 할 때도 이렇게

git config
커맨드를 사용하면 되는데요. 바로 보여드릴게요. 이렇게 적으면 됩니다.

git config alias.history 'log --pretty=oneline'
이렇게 쓰고 실행하고 나면 앞으로 git histroy라고만 써도 자동으로 git log --pretty=oneline을 실행하게 됩니다.

다음 영상부터는 git log --pretty=oneline 대신 git history를 사용하도록 하겠습니다. history는 원래 git에 있는 커맨드가 아니라 단지 제가 만든 alias라는 걸 기억하세요. 
그리고 앞으로 여러분도 여러 커맨드와 옵션들을 배울 때 길이가 너무 길어서 짧게 나타내고 싶은 것이 생기면 방금 배운 aliasing을 활용해보세요.

